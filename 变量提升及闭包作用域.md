###  作用域
   > 指的是js运行的范围

   >  作用域分两种，一种叫全局作用域，另一种叫局部作用域
   -  全局作用域：

      > 当打开浏览器解读到script标签的时候，会把js运行在一个window的全局作用域下，全局作用域会生成一个全局的活动变量对象，会把所有的变量或者函数设置为这个对象下的属性，整个window下的环境都叫做全局作用域;所以一个变量或者一个函数，默认属于window。

      >如果有多个script标签，上一个script标签报错是不会影响下面script中的代码执行的。

      >

```js
          console.log(window.a); //如果没有使用var声明变量，在赋值之前是不会把a挂在window上的，所以a是找不到的
            a = 10;
            console.log(window);//赋值之后window下就有a
```
-  局部作用域：
```js
         在运行函数的时候，函数内部会开辟一个执行栈，在执行栈中会创建一个活动变量的对象，会把函数中所有的变量、函数存储到这个活动变量，函数只会作用在函数内，这种表现叫做局部作用域

     作用域链：
         如果函数内访问不到某个变量，先去参数中找，还找不到会向父级函数查找，直到window全局，如果还找不到就报错

    -  局部作用域运行：
       1.没有形参的时候，但是有var 如果在var上方访问这个变量，结果是undefined

       2.有形参并且有实参也有var  如果在var的上方访问这个变量，结果应该是实参
 
       3. 有形参并且有实参 函数内还有函数  如果在var的上方访问这个变量，结果应该是函数

```
    
-   块级作用域
```js
   {
     console.log(a);//在上方访问块中的函数a，结果是undefined
     if(a){
         console.log(1)
     }else{
         console.log(2)
     }
     {
         //这个函数在块中，在预解析的时候会undefined
         function a(){}
     }
      console.log(a);
   }
```

###  变量提升（域解析机制）
     当浏览器去解析js的时候，会提前解析全局的变量和函数的过程。
     
     解读代码的时候记住以下两步：
     第一步： 上来就找 var 和 function声明

     第二步： 逐行解读代码，此时var和function声明就不用再去读了
        一般读的是赋值（=）,计算，输出，判断。。。

-  PK规则：
        变量没有函数大，后面的函数声明比前面的函数声明大(后面的函数声明会覆盖前面的函数声明)
```js
      function fn(){ //在函数内开辟一个执行栈
        //形参赋值
        //变量提升  var function
        //执行上下文
        //销毁作用域
        a = 30;   //window.a
    }
    fn();
        /*
          一个匿名函数自执行函数，如果带有名字，在函数体内不管如何赋值同名的变量，结果都等于这个有名函数。

        */
        var  a = 10;
        (function a(){
            a={};
            console,log(a);//还是a函数的代码块
        })
```
### 闭包
>  (1)函数嵌套函数；
   (2)子函数引用父函数的参数或者变量；
   (3)并且子函数还能被外界所引用，这个时候子函数的作用域链仍然保持着对父函数活动对象的引用，父函数的参数和量会被浏览器的垃圾机制给回收，此时打印父函数的函数返回值，会发现在返回值下面有一个scopes，这个scopes面有closure，他就是闭包(整个父级都形成了一个闭包环境)
```js
    // 计数器小例子
      btn.onclick = (function(){
        var i = 0;
        return function(){
            btn.innerHTML = ++i;
        }
    })();
```

###   var、let、const

 -  var 变量
    + 变量提升
    + 存入全局的活动变量对象中
    + 允许有多个同名的变量
    + 不支持块级作用域

-  let 变量
    + 不会变量提升且有暂存死区（在变量定义的上方都访问不到这个变量）
    + 不会存到全局的活动变量对象中
    + 不允许有多个同名的变量
    + 支持块级作用域
    
-  const 常量
    + 不会变量提升且有暂存死区（在变量定义的上方都访问不到这个变量）
    + 不会存到全局的活动变量对象中
    + 不允许有多个同名的变量
          值是不能被改变的（引用类型可以改变属性值）
    + 声明了必须赋值