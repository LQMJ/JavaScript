###  正则表达式
   - 定义：专门用来检索字符串的一种规则，更擅长处理模糊范围的字符串
   - 规则 -> 规律,现象
   - 正则也是对象
   - 正则的特性：
     + 懒惰（你让他找一个，不会找第二个，你让他找一堆，不会找第二堆）
     + 贪婪 （只要符合规则就不停的找，直到找不到为止）
    
### 正则的写法
   - {}[]''
   - new Object,new Array
   - // -> 字面量的写法（找字符的时候用//）(/不带引号的查询字符或者规则/)
   - new ReegExp（规则【可以为字符串，可以进行字符串拼接】，修饰符）->new实例的写法（可以使用变量的时候用new RegExp）

### 正则规则符
   - string.match(//)
     + 字符串match的方法
     + 找到正则匹配的字符，并且把他们放到数组中，返回值是数组，找不到就返回null
     + 与exec类似
     + str.match(/\d+/g):全局查找字符串中所有匹配规则的项，并放到一个数组中，返回值是一个数组
   - \:转义字符（把正则中含有特殊含义的字符转成字符本身（不再有任何特殊的含义）），转义字符转的是\后面的字符
   - \n:换行符
   - \d:(0~9之间的数字)代表一个数字
     + /\d+/:找到字符串中第一次出现的一个或者连续的数字
     + g ：global全局查找
   - \D:查找非数字
   - \w : 数字、字母、下划线中的任意一个字符
   - \W : 非数字、字母、下划线中的任意一个字符
   - \s ：一个空格
   - \S ：一个非空格
   - \b : 一个边界符
   - \B : 一个非边界符
   - ^ : 以哪个字符作为开始（如果^在中括号中，那么代表排除）
   - $ : 以哪个字符作为结束
   - . : 除了\n(换行符)以外的任意字符
   - | ：或者  x|y（x或者y中的一个字符）
   - [] ：在中括号中的字符在正则中是任意一个字符
     + 小写英文:[a-z]
     + 大写英文:[A-Z]
     + 拿到大写和小写的字符[A-Za-z]（ascii码的91-96是别的字符不是字母）
     + 中文的区间范围:[\uae00-u9fa5]
   - {}:代表量词
     + 描述{}前面字符的数量
     + {m,}最少m个，最多不限
     + {m,n}最少m个，最多n个
     + {m}最少出现m次，最多也出现m次
   - 量词
     + *：零到duoci
     + +: 一到多次
     + ?: 零次或者一次
   - 修饰符
     + g：global 全局匹配
     + i：忽略单词大小写
     + m：多行匹配

### 正则方法
   - 正则中常用的两个方法：exec，test
     + //.exec(字符串):找到正则匹配的字符串（首次出现的字符【就一次】），并且放到数组中，找不到就返回null（查看字符串中是否有匹配项，查找字符出现的index索引是首次出现的位置，查找的length就是1）
     + //.test(字符串)：查看字符串中是否有规则匹配项，如果有就返回true，否者返回false
   - str.replace(字符串或者正则，替换的字符串或者函数)替换
    + 细节：默认情况下，函数的
      - 第一个参数是每次匹配的字符
      - 第二个参数是匹配字符的索引
      - 第三个参数是整个字符串
      - 第四个参数是undefined
      - 如果有分组的情况下
        + 第一个参数是每次匹配的字符
        + 第二个参数是第一个分组，之后有几个分组，参数就是分组项，直到分组读完就正常走索引，整个字符串、undefined（没有分组，就是索引，有分组，就是第一个分组，第三个参数遵循一样的查找原则，后面的参数为整个字符串、undefined）
    + 分组(),从左往右数，分组之后，函数的
     - 第一个参数就是整个字符串
     - 第二个以及之后的参数是每一个数字
     - 如果分组的后面有量词，那么分组项为最后一个数字
     - 可以进行提取
    + 过滤敏感词
      - 过滤字符串中多个连续的敏感词
      - str.replace(/字符串|字符/g,function($0){let temp = '';for(let i = 0 ;i<$0.length;i++>){temp += '*'},return temp;)
      - 函数的第一个参数就是每次匹配的字符，如果匹配多次，那么会多次调用

### 重复子项（子项重定向）
   - \数字  数字代表的是一个子项，这个\数字，一定是和子项内容一致的
   - 注意:重复子项只能用在匹配子项之后
```
    //下面的代码，本来是打算匹配acbc，因为c为第三个分组
    //a后面跟了一个\3（c），\3在 c分组的前面所以匹配不成功
    let str = 'acbc';
    str.replace(/(a)\3(b)(c)/,function($0,$1){
        console.log($0);
    })

    如果要匹配'acbc'可以使用下面的方式
    str.replace(/(a)(c)(b)\2/,function($0,$1){
        console.log($0);
    });
```

### 验证一个合法的url
```
    /^(http)s?:\/\/w{3}\.[a-z]{2,18}(\.[a-z]{2,3}){1,2}\/[a-z]{1,10}\?(([a-z]\w{0,10})=([\w=%-]+)&?)+$/


    (http)s  -> http|https

    :\/\/  ->  ://

    /w{3}\. -> www.

    [a-z]{2,18} -> baidu

    (\.[a-z]{2,3}){1,2} -> .com|.cn|.com.cn|.net ...

    \/[a-z]{1,10}\?  -> /haha?    接口地址

    (([a-z]\w{0,10})=([\w=%-]+)&?)+   key=value&|key=value

```
### UrlQueryParmas
> 把url中的key和value存到对象中
```
    let str = 'https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=baidu&wd=js';

    let re = /([a-z]\w{0,10})=([\w=%-]+)&?/g
    let obj = {};
    str.replace(re,(...arg)=>{
        obj[arg[1]] = arg[2];
    });
    console.log(obj);

```   

### 千分符
```
把1000000000转换成每三个数字前添加一个逗号。
思路:重后往前找，每三个数字前就添加一个逗号。
每三个数字前的数字：\d(?=(\d{3});

let str = '1000000000';
  let temp = '';
    let num = 0;
    //循环处理
    for(let i=str.length-1;i>=0;i--){
        // console.log(num);
        // console.log(temp.length-num);
        // console.log(str.length);
        // console.log(i);
        //判断length%3是否等于0，如果等于0，说明是三位数，后面加一个逗号，如果不是那么就直接拼接，放到temp中
        if((temp.length-num)%3){
            temp+=str[i];
        }else{
            temp+=','+str[i];
            num++;
        }
    }
    // console.log(temp);
    temp = temp[0] === ','?temp.substring(1):temp;
    temp = temp.split('').reverse().join('');
    console.log(temp);

    //正则匹配
    console.log(str.match(/(\d)(?=(\d{3})+$)/g));
    console.log(str.replace(/(\d)(?=(\d{3})+$)/g,'$1,'));
```