## number数字类型
> 包含：常规数字、NaN

### NaN
> not a number：不是一个数，但它率属于数字类型

NaN和任何值（包括自己）都不相等：NaN!=NaN，所以我们不能用相等的方式判断是否为有效数字

### isNaN
> 检测一个值是否为非有效数字，如果不是有效数字返回TRUE，反之是有效数字返回FALSE

在使用isNaN进行检测的时候，首先会验证检测的值是否为数字类型，如果不是，先基于Number()这个方法，把值转换为数字类型，然后再检测

### 把其它类型值转换为数字类型
- Number([val]) 
  > 基本数据类型转数字

   + 字符串转数字      Number('')      只要字符串中含有非有效数字，结果就是NaN (出现的第一个小数点不算)
   + 布尔值转数字      Number(true)//=> 1       Number(flase)//=> 0
   + null转数          Number(null)//=> 0
   + undefined转数字    Nunmber(undefined)//=>NaN

  > 引用数字类型转数字   先把对象转为字符串，然后再转数字
   + 普通对象转数字     Number({})=>Number('[object Object]')=>NaN
   +  数组转数字         Number([])=>Number('')=>0

-  parseInt  /  parseFloat ([val],[进制])   也是转换为数字的方法

   >  parseInt  它是从左到右依次查找有效数字字符，一旦遇到非有效数字字符，停止查找（不管后面     是否还有数字，             都不在找了），把找到的当做数字返回  (只会返回整数)

              +  找不到就返回NaN  [] / ''
                
   
   >  parseFloat  对于字符串来说，它是从左到右依次查找有效数字字符，一旦遇到非有效数字字符，停止查找（不管后面                是否还有数字，都不在找了），把找到的当做数字返回  (可以返回小数)
   
   >  ==进行比较的时候，可能要出现把其它类型值转换为数字


## string字符串数据类型
> 所有用单引号、双引号、反引号（撇 ES6模板字符串）包起来的都是字符串

### 把其它类型值转换为字符串
- [val].toString()
  + 把对象转化为字符串 => '[object Object]'
  + 把数组转化为字符串,把 [] 去掉,加引号 '' 
  + 把数字、布尔转化为字符串,直接加引号
  + null和undefined不能直接调用toString方法,会报错 (可以使用字符串拼接)
- 字符串拼接
   + 在四则运算中包括加减乘除,除了加法,其他都是正常的科学运算;
   + 加法就有可能出现字符串拼接，如果在加法中出现了字符串，那就不是数学运算，就是字符串拼接
   + 在运算的过程中不是数字类型的值，先把值转换为数字类型在运算
   + 在运算加法的时候遇到字符串就直接字符串拼接 
   + 在运算过程当中出现NaN,结果就为NaN
   + 在运算的过程中如果有数组或者普通对象，就会给他转到字符串



## boolean布尔数据类型
> 只有两个值 true/false

### 把其它类型值转换为布尔类型
> 只有 0、NaN、''、null、undefined 五个值转换为FALSE，其余都转换为TRUE（而且没有任何的特殊情况）

- Boolean([val])
- !/!!
- 条件判断

## null / undefined
> null和undefined都代表的是没有

- null：意料之中（一般都是开始不知道值，我们手动先设置为null，后期再给予赋值操作）
```
let num = null; //=>let num = 0;  一般最好用null作为初始的空值，因为零不是空值，他在栈内存中有自己的存储空间（占了位置）
...
num = 12;
```

- undefined：意料之外（不是我能决定的）
```
let num; //=>创建一个变量没有赋值，默认值是undefined
...
num = 12;
```

## object对象数据类型-普通对象
> {[key]:[value],...} ：
      任何一个对象外层由大括号包裹
      都是由零到多组键值对（属性名：属性值）组成的（并且属性名不能重复）
      每个键值对有属性名和属性值组成
      键值对拿逗号隔开
      属性名由字符串或者数字
 - 查询对象中属性名对应的属性值：
    + 对象.属性名  如果属性名为数字，不能用 *对象.属性名* 去获取
    + 对象['属性名']

 -  新增/修改键值对： 对象.属性名 = xxx （如果原     来有这个属性名就是修改，如果没有就是新增）

 -  删除： 假删除=> 手动赋值为null;  
         真删除=> delete 对象.shuxingming
   
> 数组是特殊的对象数据类型
  - 外层由中括号[ ]包裹;属性名是数字 =>索引
  - length,代表数组的长度,也是数组值的个数
  - 在数组末尾追加一项 ary[ary.length] = null;

## 数据类型比较
   - 对象 == 对象     比较的空间地址

   - 字符串 == 字符串  比较ASCII值

   - 对象 == 字符串   比较的是字符串

   - 对象 == 数字     比较的是数字类型

   - 对象 == 布尔     比较的是数字类型

   - 数字 == 字符串   比较的是数字类型

   - 数字 == 布尔     比较的是数字类型

   - 字符串 == 布尔   比较的是数字类型

   - null == undefined   true  
   - null === undefined  false
   -  null和undefined和其他值都不等

   - NaN 和任何值都不相等,包括自己本身
## 数据类型检测
- typeof ：检测数据的属性（不是方法）
- instanceof ： 检测当前实例是否属于某个类
- constructor ：基于构造函数检测数据类型
- Object.prototype.toString.call():检测数据类型最好的方法

### typeof 
- 检测的返回值一定是一个字符串
- 字符串里放的是检测出来的类型
- typeof null  => 'object'
- 检测对象返回的都是'object'，不能够详细区分数组和普通对象

